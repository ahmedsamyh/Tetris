#include <Global.hpp>
#include <MoGE/MoGE.hpp>
#include <MoUI/MoUI.hpp>
#include <format>
#include <iostream>

using namespace momo;

#define W 800.f
#define H 800.f

struct MainScene : public Scene {
  Sprite bgSpr;
  Alarm blockSpawnAlarm;
  UI ui;
  bool DEBUG_DRAW = false;
  MainScene() {
    ///
    id = 0;
    setBlendMode(sf::BlendAlpha);
    bgSpr.init("block");
    bgSpr.spr.setTextureRect(sf::IntRect(0, 0, (int)SW, (int)SH));
    bgSpr.setOrigin();
    blockSpawnAlarm.init(1.f);
  };

  void init() override{
      ///
  };

  void input() override {
    if (keyPressed(Tilde))
      DEBUG_DRAW = !DEBUG_DRAW;
    // if (mousePressed(BTN_LEFT)) {
    // Vec2 pos;
    // pos.x = float(int(M2.x / TILE_SIZE) * TILE_SIZE);
    // pos.y = float(int(M2.y / TILE_SIZE) * TILE_SIZE);
    // Tetromino t(pos);
    // G::tetrominos.push_back(t);
    // }
  };

  void update(float dt) override {
    ///

    if (blockSpawnAlarm.onAlarm(dt)) {
      Vec2 actualPos = {PLAY_OFF.x + random(PLAY_AREA.x), PLAY_OFF.y};
      Vec2 pos;
      pos.x = float(int(actualPos.x / TILE_SIZE) * TILE_SIZE);
      pos.y = float(int(actualPos.y / TILE_SIZE) * TILE_SIZE);
      Tetromino t(pos);
      G::tetrominos.push_back(t);
    };

    for (auto &t : G::tetrominos) {
      t.update(dt);
      t.pos.y += 10.f * dt;
    };
  };

  void draw() override {
    ///
    drawSprite(bgSpr);
    fillRect(PLAY_OFF, PLAY_AREA, BLACK, RED);

    for (auto &t : G::tetrominos) {
      t.draw();
    };

    setCharSize(TILE_SIZE / 2);
    drawText(PLAY_OFF + Vec2(PLAY_AREA.x, 0.f), "Score: ");
    if (DEBUG_DRAW) {
      ui.begin(Vec2(2, 2));
      ui.text(std::format("Tetrominos Size: {}", G::tetrominos.size()),
              TILE_SIZE / 2);

      ui.end();
    }
  };
};

int main(int argc, const char **argv) {
  MAIN(MainScene);
  create("Tetris", SCREEN_SIZE.x, SCREEN_SIZE.y);
  run();
  return 0;
}
